# Lezione di lunedì 06 maggio 2024

## Meccanismo di challenge-response (Protocollo di autenticazione di B con A con aggiunta di freshness)

Per autenticare Bob con Alice utilizzando un meccanismo di challenge-response con l'aggiunta di freshness, si seguono i seguenti passaggi:

1. **Invio della challenge da parte di Alice:** Alice invia a Bob una nonce cifrata con la chiave pubblica di Bob, {Na}Kb.

2. **Risposta di Bob:** Bob riceve il messaggio cifrato da Alice e lo decifra con la sua chiave privata, ottenendo la nonce Na. Successivamente, Bob invia la nonce in chiaro ad Alice.

In questo protocollo, chiunque desideri confermare l'autenticità di Bob deve includere la nonce nella sua risposta e riceverla indietro intatta. Questo garantisce la "freshness" dei dati scambiati durante il processo di autenticazione.

## Come mutualizzare la garanzia di freshness? Come autenticare Alice con Bob

Per mutualizzare la garanzia di freshness e autenticare Alice con Bob, si può seguire questo protocollo:

1. **Invio della challenge da parte di Bob:** Bob invia ad Alice una nonce cifrata con la chiave pubblica di Alice, {Nb}Ka.

2. **Risposta di Alice:** Alice riceve il messaggio cifrato da Bob e lo decifra con la sua chiave privata, ottenendo la nonce WNb .

In questo modo, entrambi Bob e Alice possono essere certi che l'altro abbia ricevuto e utilizzato una nuova nonce, garantendo così la freschezza dei dati scambiati e mutua autenticazione.

## Come ottimizzare questo protocollo?

Possiamo unificare i 2 step centrali dove Bob invia informazione ad Alice, il protocollo passa da:

1. Alice invia a Bob una nonce cifrata con la chiave pubblica di Bob **{Na}Kb** (A->B: {Na}Kb)
2. Bob invia ad Alice il nonce **Na** decifrato con la sua chiave privata (B->A: Na)
3. Bob invia ad Alice una nonce cifrata con la chiave pubblica di Alice **{Nb}Ka** (B->A: {Nb}Ka)
4. Alice invia a Bob il nonce **Nb** decifrato con la sua chiave privata (A->B: Nb)

a:

1. Alice invia a Bob una nonce cifrata con la chiave pubblica di Bob {Na}Kb (A->B: {Na}Kb)
2. Bob invia ad Alice il nonce Na decifrato con la sua chiave privata ed una nonce cifrata con la chiave pubblica di Alice (B->A: Na, {Nb}Ka)
3. Alice invia a Bob il nonce Nb decifrato con la sua chiave privata (A->B: Nb)

Questa versione è sufficiente per l'autenticazione con freshness, possiamo però aggiungere un ulteriore livello di sicurezza cifrando tutte le nonce:

1. Alice invia a Bob una nonce cifrata con la chiave pubblica di Bob {Na}Kb (A->B: {Na}Kb)
2. Bob invia ad Alice il nonce Na ed una nonce Nb cifrati entrambi con la chiave pubblica di Alice (B->A: {Na, Nb}Ka) Kab = Na,Nb è un segreto condiviso
3. Alice invia a Bob il nonce Nb cifrato con la chiave pubblica di Bob (A->B: {Nb}Kb)

Quando Bob riceve da Alice il primo nonce, non sa a chi replicare il messaggio è necessario quindi aggiungere nel messaggio un riferimento al mittente, il protocollo diventa quindi:

1. Alice invia a Bob una nonce cifrata con la chiave pubblica di Bob {Na}Kb insieme ad un riferimento a se stessa per poter ricevere indietro la nonce cifrata (A->B: {Alice, Na}Kb)
2. Bob invia ad Alice il nonce Na ed una nonce Nb cifrati entrambi con la chiave pubblica di Alice (B->A: {Na, Nb}Ka) Kab = Na,Nb è un segreto condiviso
3. Alice invia a Bob il nonce Nb cifrato con la chiave pubblica di Bob (A->B: {Nb}Kb)

## Analisi del protocollo di sicurezza

- Il protocollo soddisfa il requisito di autenticazione tra Alice e Bob? Sì
- Il protocollo soddisfa il requisito di autenticazione tra Bob e Alice? Sì
- Il protocollo soddisfa la confidenzialità della coppia {Na,Nb}? Sì perchè le nonce sono sempre cifrate

## Scenario di attacco

## Scenario di attacco

Nel tentativo di comunicare con Ive, Alice invia {Alice, Na}Kive. Tuttavia, l'attaccante Dolev-Yao si finge Ive e intercetta il messaggio, ottenendo così la nonce Na di Alice. L'attaccante, impersonando Ive, manipola il flusso di comunicazione coinvolgendo Bob.

Ive, fingendosi Alice, riutilizza la nonce di Alice e, accanto ad essa, inserisce 'Alice', cifrando il tutto con la chiave pubblica di Bob. Successivamente, Bob invia a Ive la coppia {Na, Nb} cifrata con la chiave pubblica di Alice. Ive, non potendo decifrare il messaggio poiché non possiede la chiave privata di Alice, lo reinoltra ad Alice.

Alice riceve {Na, Nb}Kalice e nota che la nonce Na è tornata indietro, soddisfacendo così la challenge-response e autenticando erroneamente Ive senza rilevare alcuna anomalia nel protocollo.

Successivamente, Alice estrae la seconda nonce Nb e la rimanda a Ive, appena autenticato, cifrandola con la chiave pubblica di Ive: {Nb}Kive. In questo modo, Ive ottiene la nonce Nb cifrandola con la chiave pubblica di Bob, precedentemente nota a Ive, mentre Bob, rivedendo la sua stessa nonce Nb, non rileva anomalie e ritiene di aver autenticato con successo Alice, ignaro del fatto che il suo interlocutore è Ive.

**Abbinamento autenticazione-confidenzialità**

L'hash al messaggio 3 costituisce una soluzione a questo attacco, poiché, sebbene Ive non sia interessato al contenuto della nonce Nb, la sua mancanza di conoscenza di questa nonce previene l'attacco.

## Potenziali soluzioni

Possiamo apportare queste modifiche al protocollo originale:

**Primo fix**

1. Alice invia a Bob: {{Alice, Na}Kalice-1}Kbob

Mettiamo una cifratura con chiave privata nel messaggio 1 è ancora possibile effettuare l'attacco non è quindi un fix corretto

**Secondo fix**

1. Alice invia a Bob: {{Alice, Na}Kalice-1}Kbob
2. Bob invia ad Alice: {{Na,Nb}Kbob-1}Kalice

Possibile soluzione Alice si accorgerebbe di non star parlando con l'interlocutore corretto

**Terzo Fix**

2. Bob invia ad Alice: {{Na,Nb}Kbob-1}Kalice

Possibile semplificare il tutto modificando solo il secondo passaggio del protocollo

**Quarto Fix**

2. Bob invia ad Alice: {Na, Nb, Bob}Kalice

Possibile anche rimuovere il secondo livello di encryption, Alice non riesce ad identifcare Ive ed Ive non puuò spacciarsi per Alice agli occhi di Bob. Il senso del fix è quello di esplicitare il mittente del messaggio all'interno del crittotesto come accade esattamente ala passo 1. Da ciò ne deriva che esplicitare l'identità del mittente è rilevante

**Quinto Fix**

1. Alice invia a Bob: {Alice, Bob, Na}Kbob

Nel messaggio 1 non ci sono vulnerabilità, modificare quello non porterebbe alcuna soluzione all'attacco. Il problema dell'attacco sta al passaggio 3 che è il sintomo del problema ed è quindi necessario fixare il messaggio 3, modificando il messaggio 2 informando Alice se eventualmente tutti i controlli non sono andati a buon fine.

## Conseguenze dell'attacco

Le conseguenze di questo attacco sono significative. L'attaccante riesce a scoprire la chiave di sessione autenticandosi come Alice presso Bob, il che significa che l'attaccante può impersonare Alice e accedere ai servizi offerti da Bob utilizzando la chiave di sessione rubata. Questo è particolarmente critico nel contesto di un'applicazione web, dove il client si autentica al server tramite un cookie di sessione che contiene le nonces Na e Nb. Utilizzando questa chiave di sessione compromessa, l'attaccante potrebbe anche cifrare i messaggi, aumentando il potenziale danno dell'attacco.

Sebbene abbiamo discusso delle soluzioni per proteggere la nonce Nb, potrebbe sembrare che la protezione della nonce Na non sia stata considerata. Tuttavia, la considerazione principale è che, poiché Alice condivide la nonce Na con Ive per la sessione corrente, le sorti di Na sono meno rilevanti. Bob acquisisce Na in modo involontario a causa dell'attività fraudolenta di Ive, quindi la policy associata a Na è che è stata concepita da Alice per condividerla con Ive. 

Cambiarlo a un modello di attaccante più generale, come un attaccante generico, rende il quesito sulla confidenzialità di Na più rilevante. In questo caso, il fatto che Bob abbia acquisito la nonce in modo indesiderato potrebbe sollevare preoccupazioni sulla sicurezza dei dati e sulla privacy degli utenti.

In sintesi, mentre la protezione di Nb è prioritaria, non bisogna trascurare la protezione di Na, specialmente considerando gli scenari in cui la sicurezza dei dati e la privacy degli utenti sono in gioco.

## Vendetta nel modello general attacker

Nel modello di attaccante generico, Bob, scoprendo l'importanza della nonce Na, potrebbe pianificare una vendetta contro Ive. Supponendo che Alice sia una banca, Bob potrebbe eseguire un attacco come segue:

- Bob si impersona come Ive, utilizzando la chiave di sessione rubata {Na, Nb}, e invia a Alice la seguente richiesta:
   
   {Na, Nb, "trasferisci 20000€ dal conto di Ive al conto di Bob"}Kalice

In questo scenario, Alice (la banca) riceve la richiesta e la interpreta come legittima poiché soddisfa la challenge con la nonce Nb. Di conseguenza, esegue il trasferimento di denaro dal conto di Ive al conto di Bob, credendo che la richiesta provenga da Ive stesso.

Questo tipo di attacco rappresenta un grave rischio per la sicurezza e la fiducia nell'ambiente online. Dimostra l'importanza di proteggere sia la nonce Na che la nonce Nb e sottolinea la necessità di implementare misure di sicurezza robuste per prevenire l'usurpazione delle identità e le frodi finanziarie.

## Principio di disegno: Explicitness

È preferibile specificare chiaramente le identità del mittente e del destinatario quando queste informazioni sono rilevanti.

Ma quando sono rilevanti?

In modo sorprendente, includere il nome "Alice" nel messaggio 1 potrebbe non essere essenziale. Eliminare il riferimento ad "Alice" dal messaggio 1 potrebbe sembrare insignificante dal punto di vista della sicurezza, poiché chiunque potrebbe inserire "Alice" in quel messaggio. L'identità del mittente potrebbe essere dedotta dal livello di trasporto.

Seguire il principio di esplicitazione non è da solo garanzia di successo del protocollo, ma rappresenta un principio di prudenza fondamentale.

## Domande di esame

- Ipotesi di fix con funzione hash dello scenario di attacco (si mette l'hash nella nonce al passo 3)
- Che vuol dire prudenza nel contesto del principio di disegno